// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "WithReturnService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/protocol/TCompactProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <boost/timer.hpp>
#include "vo_relocate.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

class WithReturnServiceHandler : virtual public WithReturnServiceIf {
public:
	WithReturnServiceHandler():voRelocate(1) {
		// Your initialization goes here
		// TODO 加载所有的数据库
		boost::timer t1;
		voRelocate.db_robot1.load( "/home/bpeer/catkin_ws/src/bpeer_sj/database/database_test.db" );
		std::cout << "加载数据库耗时：" << t1.elapsed() << std::endl;
		std::cout<< "load db_robot1.size=> " << voRelocate.db_robot1.size() << std::endl;

		flag1_load_ == false;
//		test_img = 0;  // test
	}

	void resultReturn(std::string& _return, const std::string& img_, const std::string& ID_, const Data& data)
	{
		std::cout << "id: " << ID_ << std::endl;
		// TODO need to decide robotID
		if ( !flag1_load_ && ID_ == "myhid" )
		{
			// todo clear
			voRelocate.reset();
			voRelocate.db = voRelocate.db_robot1;
			std::cout<< "load db.size=> " << voRelocate.db.size() << std::endl;
			boost::timer t1;
			voRelocate.load_file( "/home/bpeer/catkin_ws/src/bpeer_sj/database/test_id_locate.txt" );
			std::cout << "load_file time: " << t1.elapsed() << std::endl;
			// load_file time: 0.000815
			flag1_load_ = true;
		}

		// Your implementation goes here
		std::vector<uchar> bytesImg( img_.begin(),img_.end());
		cv::Mat curr_image = cv::imdecode( bytesImg, CV_LOAD_IMAGE_COLOR );
		std::cout <<"***********start***********"<<std::endl;

//		char im_jpg[128];
//		sprintf(im_jpg, "%d.jpg", test_img++);
//		cv::imwrite(im_jpg, curr_image);   //  将image图像保存.jpg

		///input  baselink2odom_
		voRelocate.baselink2odom_.x = data.x;
		voRelocate.baselink2odom_.y = data.y;
		voRelocate.baselink2odom_.th = data.th;
		voRelocate.locateCb( curr_image, voRelocate.baselink2odom_ );

		std::cout << "callback  out..  " << std::endl;

//		cv::imshow("img decode", curr_image);
//		cv::waitKey(1);
		printf("test-- odom: \n");
		std::cout << "odom_x:" << data.x
		          << " odom_y:" << data.y
		          << " odom_th:" << data.th << std::endl;

		// TODO return 需要非法判断
		if ( voRelocate.result_ == NULL )
			_return = "waiting relocating..";
		else
			_return = voRelocate.result_;  //return

		std::cout << "res....: " << voRelocate.result_ << std::endl;
		voRelocate.result_.clear();  //清空上次值
		std::cout <<"***********end***********"<<std::endl;
	}

public:
	VoRelocate voRelocate;
	bool flag1_load_;

//	int test_img; //test
};

int main(int argc, char **argv) {
	int port = 10086;
	shared_ptr<WithReturnServiceHandler> handler(new WithReturnServiceHandler());
	shared_ptr<TProcessor> processor(new WithReturnServiceProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TCompactProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	server.serve();

	return 0;
}

